# 搜索

[toc]

## 1. 深度优先搜索

深度搜索有两种实现方式，一种是基于栈实现，一种是递归实现。除非特殊要求，一般都采用递归实现，简单方便又快速。代码模板如下：

```c++
void dfs(...){
    ... // 相应操作
    if(...){ // 如果相邻节点满足要求继续向下递归
    	dfs(nextnode, ...);
    }
}
```

> 但在实际项目中一般不采用递归实现，可能爆栈...

## 2. 广度优先搜索

对于节点的遍历来说，BFS和DFS的时间复杂度一致，因此一般都采用DFS实现。但广度优先搜索可以帮我们解决求“**深度、距离**”的问题，以及层次遍历。其实依据队列实现，代码模板如下：

```c++
queue<nodeType> q;
q.push(node);
while(!q.empty()){
    node = q.front();
    q = q.pop();
    // 如果需要层次遍历，则先求得q的长度k，此处新增一层循环while(k--)即可
    ... // 相应操作
    if(...){	// 如果相邻节点满足要求继续如队列
    	q.push(nextnode);
    }
}
```



## 3. 回溯法

回溯法是一种优先搜索的特殊情况，常用于需要记录节点状态的深度优先搜索。其核心操作在于在搜索到某一节点的时候，如果我们发现**目前的节点（及其子节点）并不是需求目标**时，我们**回退到原来的节点继续搜索**，并且把在目前节点**修改的状态还原**。

常用于排列、组合及选择类的问题，排列回溯的是交换的位置，而组合回溯的是否把当

前的数字加入结果中。代码模板如下：

```c++
void backtracking(...){
	if(当前节点满足最终状态){
    	// 加入结果
    }
    else if(不满足要求){
        return;	// 剪枝回溯
    }
    
    // DFS搜索
    for(...){ // 遍历满足条件的节点
        ... // 修改状态
        backtracking(...) // 往下遍历
        ... // 还原状态
    }
}
```

经典例题如46题、77题排列组合，以及51题的N皇后问题。

> 我觉得126题单词接龙是检查是否掌握搜索的好题目... 就是有点费头发....
