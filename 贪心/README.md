# 贪心

贪心的思想其实比较简单：每次都以某种原则去选择当前的最优策略，达到局部最优，最终达到全局最优。

但贪心的题目实际做起来其实是很难的，特别是当你要想清楚为什么根据当前的贪心策略能达到全局最优的时候，如果你之前没有见过类似的题型，往往是很难想的，哪怕最终做出来，可能也比较"懵"，下面介绍常见的贪心题型。

> https://leetcode.cn/circle/article/bGx1At/

**贪心算法的解题策略**：

1. 先使用一个不依靠贪心的解法X（可以使用最暴力的方式）
2. 脑补出多种贪心策略A、B、C... ...
3. 用解法X和对数器，去验证每一个贪心策略，得知哪个贪心策略正确
4. 不要去纠结贪心策略的证明（尤其在笔试场合）

#### 1. 会议安排问题

只有一个会议室，给出每个会议日程的开始和结束时间`[start, end]`，两个会议不能同时开展，如何安排使得开展的会议最多。

**解法**：按照结束时间排序，然后依次选择不冲突的会议即可。

#### 2. 构造字典序最小的字符串

存在一个若干字符串数组，我们需要构造一个字典序最小的字符串，比如`['abc', 'a'] → 'aabc'`，`['ba'，'b'] → 'bab'`。

**解法**：构造比较器 → 对于两个字符串`a`,`b`，哪个优先级更高(排序在前)，取决于规则：

```c++
bool cmp(string a, string b) {	// 当a+b字典序小于b+a时，才将a放在前面
	return a+b < b+a;
}
```

#### 3. 哈夫曼编码

有个长度为`L`的金条，要把分成`x`组，每次切割需要花费与金条长度相等的代价。问如何切割才能使整体代价最小？

比如`L=60, 需要切割[10,20,30]`，那么最少要花费`60+30=90`；比如`L=100`，需要切割`[10,20,20,20,30]`，最少需要花费`100+60+40+30=230`。

**解法**：这类题型可以利用**哈夫曼编码**的思想，先将所有元素加入优先队列中(`小顶堆`)，**每次取最小的两个进行结合**，每次结合的值就可以加到`ans`中去。核心代码如下：

```c++
while(pri_que.size() > 1) {
    int a = pri_que.top();  pri_que.pop();
    int b = pri_que.top();  pri_que.pop();
    sum += a + b;
    pri_que.push(a+b);
}
```

#### 4. 项目完成问题 - 代价 / 利润

给定一些项目，`cost[i]`表示这个需要花费的代价，`prefix[i]`表示完成这个项目增加的收益(扣除成本)，初始资金为`M`，最多能做`k`个项目。问最后最多拥有多少钱？

**解法**：每次选择项目时，都**在当前可做项目list中选择收益最大的项目**，完成项目后更新成本，再次进行选择。构造两个优先队列，一个是用于存储待解锁项目【cost-小根堆】，一个是已解锁项目【prefix-大根堆】，先把所有项目放入待解锁队列，每次根据资金M来解锁项目，然后再在解锁项目中选择最大收益的项目。

```c++
for (int i = 0; i < k; i++) {
    while (!pri_cost.empty() && pri_cost.top().first <= M) {
        pri_prefix.push(pri_cost.top());
        pri_cost.pop();
    }
    if (pri_prefix.empty())   break;
    M += pri_prefix.top().second;
    pri_prefix.pop();
}
```

