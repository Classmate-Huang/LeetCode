# LeetCode2183：统计可以被K整除的下标对数目

## 题目

给你一个下标从 0 开始、长度为 n 的整数数组 nums 和一个整数 k ，返回满足下述条件的下标对 (i, j) 的数目：

```
0 <= i < j <= n - 1 且
nums[i] * nums[j] 能被 k 整除。
```


示例 1：

```
输入：nums = [1,2,3,4,5], k = 2
输出：7
解释：
共有 7 对下标的对应积可以被 2 整除：
(0, 1)、(0, 3)、(1, 2)、(1, 3)、(1, 4)、(2, 3) 和 (3, 4)
它们的积分别是 2、4、6、8、10、12 和 20 。
其他下标对，例如 (0, 2) 和 (2, 4) 的乘积分别是 3 和 15 ，都无法被 2 整除。    

```

示例 2：

```
输入：nums = [1,2,3,4], k = 5
输出：0
解释：不存在对应积可以被 5 整除的下标对。
```


提示：

```
1 <= nums.length <= 105
1 <= nums[i], k <= 105
```

## 解法一：记忆化搜索

首先可以明确的是，对于`nums`数组中的一个数a，需要找到另外找到数`b`，数`b`一定存在一个因子满足$\frac{k}{gcd(a,k)}$，才能符合`a*b%K==0`的要求。

暴力的方法就是两次循环，找到所有满足条件的组合，但这样会超时。根据上面的提示，可以记录当前数组有多少个元素的因子为`v`（有多少个元素能被`v`整除）。如果我们能够得到这个信息，那么就可以在遍历`nums`的时候，直接找到对应的元素有多少个（`f[k/gcd(a,k)]`）。而怎么得到这个元素就要用到埃氏筛法的思想，具体见**代码**。

处理完之后，需要注意的是，在我们的遍历过程中，结果中存在了`(i,i)，(i,j)和(j,i)`三种情况，因此需要排除重复的情况，具体见**代码**。

代码如下：

```c++
class Solution {
public:
    int gcd(int x, int y){
        return x % y == 0 ? y : gcd(y, x%y);
    }

    long long countPairs(vector<int>& nums, int k) {
        // 找到数组元素+k的最大值
        int maxN = k;
        for(auto& i:nums)   maxN = max(maxN, i);
        // f[i]表示数组中为i的倍数的元素有多少个
        vector<int> f(maxN+1, 0);
        // 首先值为i的元素肯定是i的倍数
        for(auto& i:nums){
            f[i]++;
        }
        // 利用类似于埃氏筛法的思想，统计i的倍数
        for(int i=1; i<=maxN; i++){
            // 找到那些能整除i的倍数元素个数
            for(int j=i+i; j<=maxN; j=j+i){
                f[i] += f[j];
            }
        }
        // 一次遍历
        long long ans = 0;
        for(auto& i:nums){
            ans += f[k/gcd(i, k)];
        }
        // 去除重复解（i,i）(i,j)(j,i)
        for(auto& i:nums){
            if(1LL*i*i%k == 0)  ans--;
        }
        return ans/2;
    }
};
```

时间复杂度：O(nlogn)

空间复杂度：O(1e5)