# 数学问题

`LeetCode`中有很多数学问题，但涉及的知识不会太难，很多都是初高中的知识，主要考察灵活运用的能力。

#### 1. 公倍数与公因数：

求两个整数的公倍数或者公因数主要采用的是**辗转相除法**：**两个正整数a和b（a>b），它们的最大公约数等于a除以b的余数c和b之间的最大公约数**。利用辗转相除法先求得最小公因数后，才用两数的乘积除以公因数即可得到最小公倍数：

```c++
int gcd(int a, int b){
    return b==0?a:gcd(b, a%b);
}

int lcm(int a, int b){
    return a*b/gcd(a, b);
}
```

> 关于公倍数和公因数的更多求解方法可以见此博客：https://zhuanlan.zhihu.com/p/31824895 (更相减损术等)

#### 2. 质数：

质数就是其因数只有1和它本身，需要注意的是任何一个整数可以拆分为质数的乘积。通常会涉及到**埃氏筛**和**线性筛**算法，具体算法见204题。 

```c++

if(n<=1)    return 0;
vector<bool> f(n+1, true);

int ans = 0;
for(int i=2; i<n; i++){
	if(f[i]){
   		ans++;
	    if(i<sqrt(n)){ // 细节：不再判断过大的数，这些因子已经超出范围
    		for(int j=i*i; j<n; j+=i)	f[j] = false;
    	}
    }
}
```

埃氏筛法的思想也可以用到其他题目中来，如题2183[统计可以被 K 整除的下标对数目]。

#### 3. 分解质因子

给定任意一个合数x，其都可以分解若干质数相乘的形式，其中每个质数都是这个合数的质因子，这个过程也称为质因子分解。**对于每个合数，质因子分解都是唯一的**。

对于质因子分解，可以从`i==2`开始遍历，遇到每个质数`i`，对`x`进行相除，直到`x`不能被`i`整除，`i`继续增大，直到x为1。但这样对于一个非常大的`x`，可能会导致超时。

因此我们在计算x的质因子时，只需要遍历到`sqrt(x)`即可：这是因为对于每个合数`x`，其不能存在两个大于`sqrt(x)`的质因子，最多仅存在一个。所以遍历完`sqrt(x)`之后，最后判断一下`x`是否为质数即可。代码如下：

```c++
vector<pair<int, int>> primeSplit(int x){
    vector<pair<int, int>> ans;

    for(int i=2; i<=sqrt(x); i++){
        if(x % i == 0){
            int p = i, cnt = 0;
            while(x % i == 0){
                x = x / p;
                cnt ++;
            }
            ans.push_back(make_pair(p, cnt));
        }
    }
    if(x != 1)  ans.push_back(make_pair(x, 1));

    return ans;
}
```

#### 4. 丑数（容斥原理）：

指定一些丑数因子(比如2,3,5)，要找到第n个能被这些丑数因子整除的第n个数（题264，进阶题313）。此题一种的解法是使用**多指针 + DP**的策略，依次找到第`i`个最小的丑数，然后让对应的指针++，核心代码如下【时间复杂度O(n), 空间复杂度O(n)】：

```c++
f[1] = 1;	// f[i]表示第i个丑数，d[1] = 1
vector<int> p(pn, 1);	// 存储指针位置
for (int i = 2; i <= n; i++) {
    for (int j = 0; j < pn; j++) {	// 找到最小的丑数
        int temp = f[p[j]] * primes[j];
        f[i] = min(temp, f[i]);
    }
    for (int j = 0; j < pn; j++) {	// 更新指针
        int temp = f[p[j]] * primes[j];
        if (temp == f[i])   p[j]++;
    }
}
```

但如果给出的`n`值特别大的话，就不能用遍历和DP来做了，否则就会超时(题1201-为题878的进阶版)。此时就要用到"**容斥原理+二分**"的策略：给定`x`，利用容斥原理可以判断`<=x`的数中有多少个丑数，为**能被a整除 + 能被b整除 + 能被c整除 - 能被a,b整除 - 能被a,c整除 - 能被b,c整除 + 能被a,b,c整除**，并且f(x)呈现单调性，因此可以使用二分法搜索得到答案。

>  **容斥原理**：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复。(**A∪B∪C = A+B+C - A∩B - B∩C - C∩A + A∩B∩C**)

```c++
// lab为a,b的最小公倍数，lab和lac同理，labc为a,b,c的最小公倍数
while (l < r) {
    mid = (r - l) / 2 + l;
	if (mid/a + mid/b + mid/c - mid/lab - mid/lac - mid/lbc + mid/labc < n)	l = mid + 1;
    else r = mid;
}
```

#### 5. 进制转换：

通常就是让10进制数转换为其它进制，只要理解进制运算即可，比较简单，见题504。

#### 6. 算术运算：

考察用字符串实现较大值的`加减乘除`操作，如415题。或者进行平方根操作，如69.

找规律题目中，也经常出现等比数据求和：

![等比数列求和公式_互动百科| Math, Math equations, F 1](https://i.pinimg.com/236x/56/6b/c6/566bc62c757cd4e57eb5d98570f2de7e.jpg)

#### 7. 随机与采样：

主要涉及到`随机`和`采样`，如题384(随机打乱-洗牌算法)、题528(权重采样-前缀和+二分)。

有一类经典题型是根据$rand_x()$得到$rand_y()$，比如力扣471题(用`rand7()`实现`rand10()`)，这类题存在一种**通解**：核心思想是任何一个数都可以由二进制表示，假设`y`可以用三个二进制表示`0~7`，让$rand_x()$去决定每一个二进制为`0`还是为`1`，然后执行3次即可。

> 如果x为偶数，调用$rand_x()$得到的为奇数那就是0，偶数即为1。如果为奇数的话就要用到**拒绝采样**，比如`rand7()`得到`1~3`则返回0，`rand7()`得到`4~6`则返回1。同样对于$y$也采用拒绝采用，见下面的程序。

```c++
// Leetcode471 用`rand7()`实现`rand10()`
class Solution {
public:
    int get_binary(){
        int x = rand7();
        while(x==7)	x = rand7();
        if(x<4) return 0;
        return 1;
    }

    int rand10() {
        int ans = 0;
        for(int i=0; i<4; i++){
            int flag = get_binary();
            if(flag)    ans = ans*2 + 1;
            else    ans = ans*2;
        }
        if(ans < 10)    return ans+1;
        else return rand10();
    }
};
```

> 当然还有其他的解法，但不够通用。比如进行两次`rand7()`就可以得到49种组合形式，抛去其中的9中，就可以分为40类，`((row-1)*7 + (col-1))%10`，如下所示

<img src="https://pic.leetcode-cn.com/1630776258-UNMORj-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210905012406.jpg" alt="微信图片_20210905012406.jpg" style="zoom:67%;" />

#### 8. 取余操作

在某些题目中会涉及到取余的操作(比如被某个数k整除-题974)，其中有一些比较重要的操作：

```c++
int t = (x % k + k) % k;	// c++取余操作，避免得到负数
```

* (a + b) % m = a % m + b % m；(a - b) % m = a % m - b % m
* (a * b) % m = a % m * b % m；

#### 9. 其他方面

* **反向**：长度为 `n` 的整数数组，每次操作将会使 `n - 1` 个元素增加 `1` ，返回让数组所有元素相等的最小操作次数。

> **让n-1个元素加一** 相当于 **让一个元素减1**，所以直接找到最小值，统计每个元素与最小值的差即可

* **求尾随0的个数**：提供一堆数，求得所有数乘积后的尾随0个数。

  > 统计因子2的数量`s2`和因子5的数量`s5`，得到结果即为`min(s2, s5)`.

* **摩尔投票法**：一堆数中存在某个数出现的次数超过长度的一半，找出这个数(题169)。

  > ① 直接**排序找中位数**；② **摩尔投票**，维护变量`cnt`和候选人`candi`，如果当前`cnt==0`，更新候选人。然后判断目前遍历的元素是否等于`candi`，如果等于那么`cnt++`，否则`cnt--`。最后返回`candi`即可。
  
* **给定一个整数 `n`，计算所有小于等于 `n` 的非负整数中数字 `1` 出现的个数**（题233）

> 考虑每个数位上为1时有多少个数，比如设为第k位为1的数字个数如下式所示（综合考虑了各种情况）：
> $$
> \lfloor \frac{n}{10^{k+1}}\rfloor + min(10^k,max(0, n'-10^k+1))，其中n'=n\%10^k
> $$

