# LeetCode172：阶乘后的零

## 题目

给定一个整数 `n` ，返回 `n!` 结果中尾随零的数量。

**进阶：**你可以设计并实现对数时间复杂度的算法来解决此问题吗？

 

**示例 1：**

```
输入：n = 3
输出：0
解释：3! = 6 ，不含尾随 0
```

**示例 2：**

```
输入：n = 5
输出：1
解释：5! = 120 ，有一个尾随 0
```

**示例 3：**

```
输入：n = 0
输出：0
```

 

**提示：**

- `0 <= n <= 104`



## 解法一：除以5的倍数

此题若直接按照`阶乘`的思路去做的话，会面临数据溢出的问题。因此要明确思路：出现后缀0往往是由于因子中存在`5*2`的情况，而在阶乘相乘过程中，`5`因子出现的次数远远比`2`要多得多。比如`1*2*3*(2*2)*5*(2*3)*7*(2*4)*9*(2*5)....`。因此问题只需要转换为求解阶乘式中存在多少个`5`因子即可：

```c++
class Solution {
public:
    int trailingZeroes(int n) {
        int ans = 0;
        for(int i=5; i<=n; i+=5){
            int t = i;
            while(t){
                if(t%5==0){
                    ans += 1;
                    t /= 5;
                }
                else    break;
            }
        }
        return ans;
    }
};
```

时间复杂度：O($n$)，循环遍历$1/5n$次，按理说求5因子应该是O($log{n}$)操作，但由于很多数字均不为5因子数，可视作O(1)操作。

空间复杂度：O(1)

## 解法二：5的幂因子

对于阶乘`n!`，可以写为`1*2*3*4*5*...(2*5)...(3*5)...*N`，N个数字中每5个数中就有一个能被5整除的数。因此`n/5`作为5因子的个数，但要注意`25=5*5`存在两个5因子，`125=5*5*5`存在三个5因子。

因此，最后5因子的个数可以视为$\frac{n}{5}+\frac{n}{25}+\frac{n}{125}+...$，代码实现如下：

```c++
class Solution {
public:
    int trailingZeroes(int n) {
        int ans = 0;
        while(n){
            ans += n/5;
            n /= 5;
        }
        return ans;
    }
};
```

时间复杂度：O($logn$)

空间复杂度：O(1)