# LeetCode969：煎饼排序

## 题目

给你一个整数数组 `arr` ，请使用 **煎饼翻转** 完成对数组的排序。

一次煎饼翻转的执行过程如下：

- 选择一个整数 `k` ，`1 <= k <= arr.length`
- 反转子数组 `arr[0...k-1]`（**下标从 0 开始**）

例如，`arr = [3,2,1,4]` ，选择 `k = 3` 进行一次煎饼翻转，反转子数组 `[3,2,1]` ，得到 `arr = [**1**,**2**,**3**,4]` 。

以数组形式返回能使 `arr` 有序的煎饼翻转操作所对应的 `k` 值序列。任何将数组排序且翻转次数在 `10 * arr.length` 范围内的有效答案都将被判断为正确。

 

**示例 1：**

```
输入：[3,2,4,1]
输出：[4,2,4,3]
解释：
我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。
初始状态 arr = [3, 2, 4, 1]
第一次翻转后（k = 4）：arr = [1, 4, 2, 3]
第二次翻转后（k = 2）：arr = [4, 1, 2, 3]
第三次翻转后（k = 4）：arr = [3, 2, 1, 4]
第四次翻转后（k = 3）：arr = [1, 2, 3, 4]，此时已完成排序。 
```

**示例 2：**

```
输入：[1,2,3]
输出：[]
解释：
输入已经排序，因此不需要翻转任何内容。
请注意，其他可能的答案，如 [3，3] ，也将被判断为正确。
```

 

**提示：**

- `1 <= arr.length <= 100`
- `1 <= arr[i] <= arr.length`
- `arr` 中的所有整数互不相同（即，`arr` 是从 `1` 到 `arr.length` 整数的一个排列）

## 解法一：模拟

首先要看清楚题目要求，它并没有要求我们找到最少次数的解法，而只是将翻转次数限制在`10 * arr.length` 之内（实际上论文证明找到最少次数是NPC问题）。并且这个题目坑爹的一点就在于，从官方示例中，我们并不能看出任何规律，甚至错误引导。

其实这个题目抛开官方示例来想会更简单，因为煎饼翻转是翻转`arr[0...k]`子数组，那么只要先将最大的数字放到最末尾就可以缩小问题规模了。比如`[3,2,4,1]`，我们想办法把4先放到最末尾，剩下的问题就是解决数组长度为3的煎饼排序。

按照上述思想，很容易得到解法：对于一个长度为n的数组，首先找到n值下标k，然后翻转arr[0..k]，让n位于首部；接下来，翻转arr[0...n-1]，即可让n位于最尾部。剩下就是将问题规模缩小至n-1，一直迭代下去知道n=1为止。这样，长度为n的数组只需要进行2*(n-1)次煎饼翻转，满足题目要求。代码如下：

```c++
class Solution {
public:
    int findX(int x, vector<int>& arr){
        for(int i=0; i<arr.size(); i++){
            if(arr[i]==x)   return i;
        }
        return -1;
    }

    vector<int> pancakeSort(vector<int>& arr) {
        int n = arr.size();
        vector<int> ans;

        for(int k=0; k<n-1; k++){
            int x = findX(n-k, arr);
            // 已经位于末尾
            if(x == n-k-1) continue;
            // 两次翻转
            reverse(arr.begin(), arr.begin()+x+1);
            ans.push_back(x+1);
            reverse(arr.begin(), arr.begin()+n-k);
            ans.push_back(n-k);
            
        }

        return ans;
    }
};
```

时间复杂度：O($n^2$)

空间复杂度：O(1)