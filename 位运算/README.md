# 位运算

`&`按位与，`|`按位或,`~`按位非,`^`按位异或,`<<`算术左移,`>>`算术右移，这里就不介绍其基本运算了。

有一些常用的技巧：

① `n&(n-1)`可以去掉n的二进制中最低的`1`，比如`00011010 & 00011001 = 11000`；

② `n&(-n)`可以找到n的二进制中最低的`1`，比如`00011010 & 11100110 = 00000010`。

简单的位运算操作：比如136，190，461，231题等等。

利用位运算辅助：比如318题-最大单词的长度乘积，采用位运算来存储每个字符串的字母出现情况，方便后续判断两个字符串是否含有相同字符。

#### bitset

一般情况下，使用`int`表征二进制进行位运算已经足够强大了。但有时候，使用`bitset`会给我们带来很多方便，代码如下：

```c++
#include <bitset>		// 头文件
bitset<8> a;	// 无参构造，长度为8，默认为0
bitset<8> b("111");	// 右对齐, 表示0000 0111

b.count();	// b中‘1’的个数
b[7] = 1;   // 将b[7]置为1		变为 1000 0111
b.set();	// 所有位都设为1    1111 1111
// ~b 取反  a&b 与运算	a|b 或运算 a^b 异或运算
```

#### 位图bit map

`bitset`的操作有时候没有那么方便，特征是涉及到一些状态的跳转时，因为它没有实现`+ -`操作。因此很多时候是使用`int`来模拟一个32位的二进制，但如果需要更多的状态值应该怎么办呢？

使用`vector<int> arr`来模拟多位状态，vector中每个元素都表示一个32位的状态(`0~31`,`32~63`,...)

```c++
int bit = (arr[i/32] >> (i%32)) & 1;	// 获取i位置上的状态(0 / 1)
arr[i/32] = (arr[i/32]) | (1 << (i%32));	// 将i位置上的状态置为1
arr[i/32] = (arr[i/32]) & (~(1 << (i%32)));	// 将i位置上的状态置为0
```

#### 状态压缩

通常使用bit来指示一些状态，比如"已经遍历了哪些点"，"目前已存储了哪些字母"等等。这常用于回溯 or 动态规划类题型的场景中，这会涉及到一些常用操作，比如：

```c++
/* 1. 元素c是否在状态中  2. 插入新元素 */
    A & (1<<C);			A |= 1<<C；
```

