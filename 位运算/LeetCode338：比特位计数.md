# LeetCode338：比特位计数

## 题目

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

 

**示例 1：**

```
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
```

**示例 2：**

```
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

 

**提示：**

- `0 <= n <= 105`

 

**进阶：**

- 很容易就能实现时间复杂度为 `O(n log n)` 的解决方案，你可以在线性时间复杂度 `O(n)` 内用一趟扫描解决此问题吗？
- 你能不使用任何内置函数解决此问题吗？（如，C++ 中的 `__builtin_popcount` ）



## 解法一：简单遍历

利用`n & (n-1)`可以移除最后一位`1`的特性，判断当前数字中含有多少个`1`：

```c++
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> ans;
        for(int i=0; i<=n; i++){
            int cnt = 0, t = i;
            while(t){
                cnt++;
                t = t&(t-1);
            }
            ans.push_back(cnt);
        }
        return ans;
    }
};
```

时间复杂度：O(n)，遍历1个数的循环为常数量(最大32)

空间复杂度：O(1)

## 解法二：动态规划

假设前`i-1`个数字已经求得结果，对于第`i`个数字，如果其最后一位为`1`，那么`f[i]=f[i-1]+1`，如果最后一位不为`1`，那么`f[i]=f[i>>1]`。

```c++
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> ans(n+1, 0);

        for(int i=1; i<=n; i++){  // 从1遍历到n
            if(i&1){
                ans[i] = ans[i-1]+1;
            }
            else{
                ans[i] = ans[i>>1];
            }
        }

        return ans;
    }
};
```

时间复杂度：O(n)

空间复杂度：O(1)