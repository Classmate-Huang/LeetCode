# 剑指offer 03：数组中重复的数字

## 题目

找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

```输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```


限制：

2 <= n <= 100000

## 解法一：空间复杂度为O(1)

最容易想到的解法就是设置一个`unordered_set`来记录出现了哪些数字，当遇到重复数字时返回即可时间复杂度和空间复杂度都是O(n)。但这题还可以继续提升性能，使得空间复杂度为O(1)。

题目的一个特点在于给出的`nums`数组中所有数字都在0~n-1之间，利用**桶排序**的思想，如果不存在重复数字，那么会存在一种排列，使得每个数字都会落于对应的位置上【`nums[i] == i`】。

那么对于这个问题我们可以遍历数组，让每个数字m落在对应的位置`nums[m]`上，如果位置`nums[m]`上本身已有对应的数字，则找到了重复数字；否则就交换`nums[i]`和`nums[m]`即可。

代码如下：

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        int n = nums.size();
        for(int i=0; i<n; i++){
            while(nums[i] != i){
                int m = nums[i];
                // 对应位置上已存在该元素
                if(nums[m] == m)    return m;
                // 交换元素
                swap(nums[i], nums[m]);
            }
        }
        return -1;
    }
};
```

时间复杂度：O(n)

空间复杂度：O(1)