# LeetCode279：完全平方数

## 题目

给定正整数 *n*，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 *n*。你需要让组成和的完全平方数的个数最少。

给你一个整数 `n` ，返回和为 `n` 的完全平方数的 **最少数量** 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

 

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

 

**提示：**

- `1 <= n <= 104`

## 解法一：DP

子问题定义为`f[i]`和为`i`的完全平方数最小个数，从`1`开始遍历，存储每个结果。在求解f[i]时，先判断其是否已经为完全平方数，如果不是则分割为两部分之和，`f[j]+f[i-j], j∈[1,n/2]`，遍历后保留最小值。但这样会超时。

**改进**：由于因子一定为完全平方数，所以可以直接分割为`f[j]+f[i-j]，j为完全平方数1,4,9...<i`，因此可以改写代码。如下所示：

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> f(n+2, 0);
  
        for(int i=1; i<=n; i++){
            // 已为完全平方数
            if(pow(int(sqrt(i)), 2)==i){
                f[i] = 1;
                continue;
            }
            // 分割
            int res = INT_MAX;
            for(int j=1; j*j<i; j++){
                res = min(res, f[i-j*j]+1);  // j*j为完全平方数，因此f[j]=1
            }
            f[i] = res;
        }

        return f[n];
    }
};
```

时间复杂度：O($n\sqrt{n}$)

空间复杂度：O(n)