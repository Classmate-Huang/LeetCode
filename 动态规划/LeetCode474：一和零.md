# LeetCode474：一和零

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的大小，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

 

**示例 1：**

```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```

**示例 2：**

```
输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
```

 

**提示：**

- `1 <= strs.length <= 600`
- `1 <= strs[i].length <= 100`
- `strs[i]` 仅由 `'0'` 和 `'1'` 组成
- `1 <= m, n <= 100`



## 解法一：0-1背包问题（空间压缩）

本题仍是一个0-1背包问题，与经典的背包问题不一样的地方在于其有`0和1`两个背包。物体就是每个字符串，物体的重量就是字符串中`0、1`出现的次数，价值都是1，求在`0`背包容量为m和`1`背包容量为n的情况下所能带走的最大价值。

相较于0-1背包，这里在实现时需要注意2个背包需要多加一层循环，存储空间也从O(w)变成了O($w^2$)。代码如下(直接上状态压缩后的代码)：

```c++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> f(m+1, vector<int>(n+1, 0));

        for(string& s:strs){
            int cnt0 = 0, cnt1 = 0;
            for(char & t:s){
                if(t=='0') cnt0++;
                else cnt1++;
            }
            for(int i=m; i>=cnt0; i--){
                for(int j=n; j>=cnt1; j--){
                    f[i][j] = max(f[i][j], f[i-cnt0][j-cnt1]+1);
                }
            }
        }

        return f[m][n];
    }
};
```

