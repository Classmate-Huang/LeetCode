# LeetCode650：只有两个键的键盘

## 题目

最初记事本上只有一个字符 `'A'` 。你每次可以对这个记事本进行两种操作：

- `Copy All`（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。
- `Paste`（粘贴）：粘贴 **上一次** 复制的字符。

给你一个数字 `n` ，你需要使用最少的操作次数，在记事本上输出 **恰好** `n` 个 `'A'` 。返回能够打印出 `n` 个 `'A'` 的最少操作次数。

 

**示例 1：**

```
输入：3
输出：3
解释：
最初, 只有一个字符 'A'。
第 1 步, 使用 Copy All 操作。
第 2 步, 使用 Paste 操作来获得 'AA'。
第 3 步, 使用 Paste 操作来获得 'AAA'。
```

**示例 2：**

```
输入：n = 1
输出：0
```

 

**提示：**

- `1 <= n <= 1000`

## 解法一：DP

设`f[i]`表示要构建长度为i的字符串需要的最少操作次数，只有“复制全部”和“粘贴”两种操作。如果`j`可以整除`i`，先构建`j`个`A`，这需要`f[j]`的操作次数，然后再考虑如何把`j`个`A`拼接成`i`个`A`，这相当于`f[i/j]`。

因此，可以构造状态转移方程为`f[i]=min{f[i], f[j]+f[i/j]}`。代码如下：

```c++
class Solution {
public:
    int minSteps(int n) {
        vector<int> f(n+1, n);
        f[1] = 0;

        for(int i=2; i<=n; i++){
            f[i] = i;
            for(int j=1; j*j<=i; j++){ // 只需要考虑sqrt(i)范围内即可
                if(i%j==0){
                    f[i] = min(f[i], f[j] + f[i/j]);
                }
            }
        }

        return f[n];
    }
};
```

时间复杂度：O($n^2$)

空间复杂度：O(n)

## 解法二：素数分解

从另一种角度理解，假设目前n个`A`的构成方式可以为：`CPPCPCPPP`，可以分解为`[CPP] [CP] [CPPP]`三个阶段，第一个阶段生成`3`个`A`，第二个阶段在`3`个`A`的基础上进行粘贴，生成了`6`个A，...

每个阶段的操作次数为`n1,n2,n3,....`，那么最后生成的字符串长度即为`n=n1xn2xn3x...`，操作数为`n1+n2+n3+...`。那么这个题目就相当于对输入`n`进行因子分解，并且使得因子和最小。

并且可以证明`n1,n2`这些数均为素数时，得到的和最小，假设某个阶段的`n1`不为素数，那么它一定可以拆分成两个素数的乘积`p1*p2`，可以证明当`p1,p2`均大于2时，`p1+p2≤p1*p2`，从而得证。

因此这个题目经过变化，变成了对输入`n`进行素数因子分解，代码如下：

```c++
class Solution {
public:
    int minSteps(int n) {
        int ans = 0, d = 2;

        while(n!=1){
            while(n%d==0){
                n = n/d;
                ans += d;
            }
            d++;
        }

        return ans;
    }
};
```

时间复杂度：O($\sqrt{n}$)

空间复杂度：O(1)

