# 动态规划


## 动态规划简介

动态规划是通过解决子问题并**存储子问题的解**，最后得到整个问题的最优解的一种解题手段。它只能用于解决最优子结构的问题（局部最优能决定全局最优）。看概念不理解没关系，多做几个题就能理解一二了。

解决动态问题的关键是找到状态转移方程，确定子问题是什么，如何通过子问题求解最终问题。这一步通常是最最最难的...

其次为了节省空间，有时候需要对动态规划进行空间压缩。其实就是找到状态转移方程的核心内容，只保留对后续求解父问题有用的子问题解，从而降低空间复杂度。

> 最简单的入门题：70题爬楼梯、198题打家劫舍，初体验状态转移方程、空间压缩技巧

动态规划可以看做是一种带有状态记录的优先搜索。这也决定了动态规划常用的两种解题思路：① 自上而下，在优先搜索时存储子问题的结果，之后遍历到该问题时直接返回存储的结果。从父问题搜索到子问题，常用于得到完整路径的题目。 ②  自下而上，先解决子问题再解决父问题，常用于得到最终解的题目。 

**怎么动态规划：** 当然题目做的多了自然会想到动态规划，三步走：① 定义状态数组；② 思考转移方程；③ 考虑边界条件。但其实很多题目，很难直接想到动态规划的解题思路，所以，很多时候不妨先想想如何“暴力”地解决这个问题，再思考哪些中间状态可以存储下来。

## 经典题型

#### 1. 最短路径问题

通常是要求从某个起点出发，到某个终点结束，它们之间的最短路径（64题、542题）。这类题型通常只需要**考虑每个节点作为终点的情况**即可，状态转移方程也通常比较容易写出来。

比如[圆环回原点问题](https://mp.weixin.qq.com/s?__biz=MzkxMDMxMjY2OA==&mid=2247483755&idx=1&sn=662a60c30888d810d7ee95aef39f8b43&chksm=c12c14d8f65b9dcee8403eac6cbf8b3e172d0d5ed7eec5cf47c234f4f216bd5975dcd99e67e2&scene=21#wechat_redirect)，其递归关系式为$f[i][k]=f[(i+1)\%n][k-1]+f[(i-1+n)\%n][k-1]$

#### 2. 正方形/矩阵问题

定义一个二维`dp`数组，其中**`dp[i][j] `表示满足条件的，以 (i, j) 为右下角坐标矩形的属性**（比如正方形边长 or 积分矩阵），这类题型的状态转移方程`F[i][j]`通常需要考虑`F[i-1][j],F[i][j-1],F[i-1][j-1]`的状态。

以221题和1277题（最大正方形）为例，`F[i][j] = min(F[i][j-1], F[i-1][j], F[i-1][j-1]) + 1`：

<img src="https://pic.leetcode-cn.com/14aa58be2ea5c9b36a722db76d2e843c4c909e312223a8461a3d2d93bc734b42-1277-1.png" alt="1277-1.png" style="zoom: 25%;" />

<img src="https://pic.leetcode-cn.com/dfcaa5390732f1b9d1d9c71f696957cbc91904c52e23705a061bae727228126d-1277-2.png" alt="1277-2.png" style="zoom:25%;" />

#### 3. **分割类问题**：

分割类问题通常**不依赖相邻的位置**，而是依赖于**满足分割条件的位置**，这个时候就需要根据具体的题意来分割子问题。

a. 例如279题（完全平方数）需要考虑将数`n`拆分为`x`和`y`（其中`x`为完全平方数），`f[i] = min(f[i], f[i-x] + 1)`;

b. 例如91题（解码方法）需要考虑两种解码情况：① `s[i]`可以单独编码 `f[i] += f[i-1] `；② `s[i]`可以组合编码`f[i] += f[i-2]`.

c. 139题（单词拆分）需要判断字符串是否能被拆分成各个单词，将字符串依次拆分，判断前`j`个字符和剩下的字符是否能被成功拆分即可。

#### 4. **子序列问题**

子序列问题通常需要定义一个`dp`数组，其中`dp[i]`表示**以 i 结尾的子序列的性质**。在处理好每个位置后，统计一遍各个位置的结果即可得到题目要求的结果。

a. 例如1143题（最长公共子序列），设置`f[i][j]`表示`s1前i个字符`和`s2前j个字符`的最长公共子序列长度。仍然存在两种条件：① 不去匹配`s1[i]`和`s2[j]`时，`f[i][j] = max(f[i-1][j], f[i][j-1])`，② 匹配``s1[i]`和`s2[j]`时(需要`s1[i] == s2[j]`)，此时`f[i][j] = max(f[i][j], f[i-1][j-1]+1)`.

b. 72题（编辑距离），构造`f[i][j]`表示`s1前i个字符`和`s2前j个字符`的的最小编辑距离，核心代码如下：

```c++
if(s1[i-1]==s[j-1]){
	f[i][j] = f[i-1][j-1]
}
else{
	min(f[i-1][j-1]+1, f[i-1][j]+1, f[i][j-1]+1)    
}
```

#### 5. 区间问题

和第4点的子序列问题非常相似，对于每个元素`nums[i]`有两种考虑方式：① 选 和 ② 不选。如果选的话是如何转移状态，如果不选的话如何转移状态。

比如笔试常考察的"**求余数问题**"，比如给你一组数据`nums`，从中任意选取一些数是k的倍数，求最大的子集和。核心代码如下：

```c++
// 二维数组f[n+1][k]，f[i][j]表示考虑前i个数除k的余数为j的最大子集和
for(int i=0; i<n; i++){
	for(int j=0; j<k; j++){
        // 是否选取nums[i]
        f[i+1][j] = max(f[i+1][j], f[i][j]);	// 不选
        f[i+1][j] = max(f[i+1][j], f[i][(j-nums[i]%k+k)%k]+nums[i]);	// 选了
    }
}
```

#### 6.背包问题

N个物品、背包容量为W，每个物品体积为w，价值为v，要求得能装载最大价值物品的方法。如果每个物品只能拿一次称之为`0-1背包问题`，不限定物品数量，称之为`无界背包问题或完全背包问题`。

> **0-1背包问题**：定义二维`dp`数组，其中`dp[i][j] `表示**前i个物体**在**容量为j**的情况下能装载的最大价值。状态转移方程为：① 第i个物体不装载，`dp[i][j]=dp[i-1][j]`；② 装载第i个物品，`dp[i][j]=v[i]+dp[i-1][j-w]`。然后取①②两种情况的最大值即可。

代码模板：

```c++
int knapsack(vector<int> w, vector<int> v, int N, int W){
    vector<vector<int>> f(N+1, vector<int>(W+1, 0));
    for(int i=1; i<=N; i++){
        int tw = w[i-1], tv = v[i-1];
        for(int j=1; j<=W; j++){
            if(j>tw){  // 首先确保要物品i能装载到背包里
            	f[i][j] = max(f[i-1][j], f[i][j-tw]+tv);
            }
            else{
                f[i][j] = f[i-1][j];
            }
        }
    }
    return f[N][W];
}
// 时间复杂度和空间复杂度均为O(NW)

// 可以空间压缩，使得空间复杂度为O(w).可以发现每一次的状态更新，都只依赖于上一层f[i-1]的状态。
// 所以可以去掉f第一个维度，f[j]=max(f[j], f[j-tw]+tv)，需要注意的是，此时要逆向遍历。
// 若正向遍历，则f[j-tw]已被更新为物品i时的状态，从而导致结果错误.
int knapsack(vector<int> w, vector<int> v, int N, int W){
    vector<int> f(W+1, 0);
    for(int i=1; i<=N; i++){
        int tw = w[i-1], tv = v[i-1];
        for(int j=W; j>=tw; j--){
            f[j] = max(f[j], f[j-tw]+tv); // 逆向，使用上一层旧数据
        }
    }
    return f[W];
}
```

> 经典题目：416题，474题

> **完全背包问题**：选择物品时不再是0或1，而是可以选择无限个。但其实也不是无限个，由于背包的体积是有限的，所以物体也是有限的。因此需要考虑在当前容量下可装载的物体i上限，那么在0/1背包的基础上，多加上一层循环即可`for(int k=0; k<=j/tw; k++)`，状态转移方程也变为` f[i][j]=max(f[i-1][j], f[j-tw*k]+tv*k) f[j]=max(f[j], f[j-tw*k]+tv*k)`。
>
> 
>
> 但这种朴素的做法无疑增加了时间复杂度，特别是当背包容量很大，而物体体积很小时，复杂度会非常高。仔细分析后可以发现，只需要将状态转移方程改为`f[i][j]=max(f[i-1][j], f[i][j-tw]+tv)`即可。详细原因可看本节最后推荐的视频讲解资料【简单的说就是`f[i][j-tw]`已经考虑到拿tv物品的情况了】。

代码模板：

```c++
int knapsack(vector<int> w, vector<int> v, int N, int W){
	vector<vector<int>> f(N+1, vector<int>(W+1, 0));
    for(int i=1; i<=N; i++){
        int tw = w[i-1], tv = v[i-1];
        for(int j=0; j<=W; j++){
            if(j>tw){
                f[i][j] = max(f[i-1][j], f[i][j-tw]+tv)
            }
            else{
                f[i][j] = f[i-1][j];
            }
        }
    }
    return f[N][W];
}

// 由于完全背包问题也只跟上一层相关，且可以采用状态压缩.
// 与0-1背包一致，f[j]=max(f[j], f[j-tw]+tv),但这里采用的是正向遍历！与新状态相关。
// 状态压缩后代码
int knapsack(vector<int> w, vector<int> v, int N, int W){
	vector<int> f(W+1);
    for(int i=1; i<=N; i++){
        int tw = w[i-1], tv = v[i-1];
        for(int j=tw; j<=W; j++){ // 正向遍历即可
            f[j] = max(f[j], f[j-tw]+tv);
        }
    }
    return f[W];
}
```

> 背包问题系列的视频讲解资料：https://www.bilibili.com/video/BV1C7411K79w?p=2
>
> **核心**：0-1逆向遍历；完美正向遍历。

> 经典题型：322题

#### 7. **股票问题** *

股票问题是一个完整的系列，基本上可以用动态规划求解，详见此博客：https://leetcode-cn.com/circle/article/qiAgHn/，核心思想是用`f[i][k][0]`模拟第i天结束后最多经过k次交易并且此时手中所持股票为0的最大收益，`f[i][k][1]`模拟第i天结束后最多经过k次交易且手中所持股票数为1的最大收益。状态转移方程如下：

```c++
f[i][k][0] = max(f[i-1][k][0], f[i-1][k][1]+price[i])  // 休息 or 卖出之前所持有的股票
f[i][k][1] = max(f[i-1][k][1], f[i-1][k-1][0]-price[i]) // 休息  or  买入今天的股票
// --- 边界条件 / 基准条件 --- //
f[i][0][0] = 0; f[0][k][0] = 0; // 收益为0的情况： 无法交易 or 交易日开始之前 
f[i][0][1] = -inf; f[0][k][1] = -inf; // 无法存在的情况： 没有开始股票交易时无法持有股票
```

注意： 因为每次交易包含两次成对的操作，**买入**和**卖出**。只有**买入**操作会改变允许的最大交易次数。

> 考虑到具体问题，都可以对其进行优化 - 时间 or 空间

#### 8. 状态压缩DP*

将状态表示为二进制，通常为对集合中某些值的选取（0表示不选择，1表示选择）。比如一个集合中的元素为：[1,2,3,4,5]，那么可以用5位二进制来表示选取状态，比如3就表示`11`，表示选取了[1,2]两个元素。

> 状态压缩可以用于DFS记忆化搜索的题，用于表示状态

经典的**TSP**问题就可以用状态压缩dp来解决。在力扣这类题型较少出现，但也有，比如题1349就是一个较为标准的状态压缩dp问题。

三个要素：① 状态定义； ② 状态转移方程； ③ 边界条件

几个关键位运算操作：1. 元素c是否在状态中：A & (1<<C)  2. 插入新元素：A |= 1<<C；

> 还有题698和473虽然可以用回溯解决，但最优解法都应该是采用状态压缩DP

