# LeetCode1049：最后一块石头的重量II

## 题目

有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

 

示例 1：

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

示例 2：

```
输入：stones = [31,26,33,21,40]
输出：5
```


提示：

```
1 <= stones.length <= 30
1 <= stones[i] <= 100
```

## 解法一：动态规划

这个题目的破题点在于将原问题转换成**集合分割**的问题，将给出的数组分成两堆A和B (`sum(A)≥sum(B)`)，在最优的划分下【`sum(A)-sum(B)`最小】，一定能找出一种碰撞方法使得最终的石头重量是`sum(A)-sum(B)`（为0表示全部碰撞完）。

现在就相当于"**目标和**"的解法，在每个元素前添加"+"(A)或者"-"(B)，使得最终的结果最小。我们考虑B集合的选择，假设所有元素的总和为`sum`，那么B的选择结果越接近`sum/2`越好。最终的结果即为`sum-2*sum(B)`。

所以最后还是回归到0-1背包的解法，从N个物品中选择容量上限为W的最大价值（N石头数量，W为总和/2）。这里直接贴上空间压缩后的代码：

```c++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for (auto i : stones)   sum += i;
        int target = sum / 2;
        
        vector<int> f(target+1, 0);    // f[i]背包容量为i时可装的最大价值
        for (int i = 0; i < stones.size(); i++) {
            int tw = stones[i], tv = stones[i];
            for (int j = target; j >= tw; j--) {
                f[j] = max(f[j], f[j-tw]+tv);
            }
        }
        
        return sum - 2*f[target];
    }
};
```

时间复杂度：O(n*m)，n为石头数量，m为重量总和的一半

空间复杂度：O(m)