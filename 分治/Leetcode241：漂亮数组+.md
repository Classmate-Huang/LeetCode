# Leetcode241：漂亮数组

## 题目

对于某些固定的 `N`，如果数组 `A` 是整数 `1, 2, ..., N` 组成的排列，使得：

对于每个 `i < j`，都**不存在** `k` 满足 `i < k < j` 使得 `A[k] * 2 = A[i] + A[j]`。

那么数组 `A` 是漂亮数组。

 

给定 `N`，返回**任意**漂亮数组 `A`（保证存在一个）。



**示例 1：**

```
输入：4
输出：[2,1,4,3]
```

**示例 2：**

```
输入：5
输出：[3,1,2,5,4]
```



**提示：**

- `1 <= N <= 1000`



## 解法一：分治

对于任意的`i<k<j`都不存在`A[k]*2=A[i]+A[j]`，对于等式左边的`A[k]*2`其必然为偶数，那么只要`A[i]+A[j]`一个为奇数，另一个为偶数即可。对于`1~N`的N个数字中，存在`(N+1)/2`个奇数和`N/2`个偶数，现在将奇数放在前半部分`L`，偶数放在后半部分`R`，如果`i`出现在前半部分，`j`出现在后半部分，那么条件即可满足。那么对于`i,j`同时出现在同一部分怎么办？这里就要采用分治的思想了，将前半部分和后半部分当做一个子问题来考虑。

这里要利用一个数学规律，如果`A[k]*2!=A[i]+A[j]`，那么经过线性变换后`a(A[k]*2)+b!=a(A[i]+A[j]+b)`将仍成立。对于前半部分`L`，里面存在`N+1/2`个奇数（1,3,5,7,...）经过线性变化(a=1/2, b=1/2)可以变为(1~N+1/2)的数组（1,2,3,...），原问题就变求`1~N+1/2`的漂亮数组。同理`R`也能经过线性变化，变为求`1~N/2`的漂亮数组。

```c++
class Solution {
public:
    unordered_map<int, vector<int>> m = {{1, {1}}};  // memorization
    vector<int> beautifulArray(int n) {
        if(m.find(n)!=m.end()){
            return m[n];
        }
        vector<int> L, R;
        L = beautifulArray((n+1)/2);
        R = beautifulArray(n/2);
        // 组合时需要注意先经过线性变化
        for(auto& i:L){  // 映射到奇数
            i = i*2-1;
        }
        for(auto& j:R){  // 映射到偶数
            j = j*2;
        }
        L.insert(L.end(), R.begin(), R.end());
        m[n] = L;
        return L;
    }
};
```

时间复杂度：O($nlogn$)

空间复杂度：O($n$)

